<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Afiq — S3 Image Uploader</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 0; background:#0f172a; color:#e2e8f0; display:grid; place-items:center; min-height:100vh; }
    .card { width:min(820px,94vw); background:#111827; border:1px solid #1f2937; border-radius:16px; padding:24px; box-shadow:0 10px 30px rgba(0,0,0,.35); }
    h2 { margin:0 0 8px; }
    .muted { color:#9ca3af; font-size:13px; }
    .btn { padding:10px 16px; border-radius:10px; background:#2563eb; color:#fff; border:0; cursor:pointer; font-weight:600; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .btn.ghost { background:#334155; }
    .btn.gray { background:#6b7280; }
    .row { display:flex; gap:10px; flex-wrap:wrap; margin:10px 0; }
    progress { width:100%; height:12px; margin-top:10px; }
    .thumb, .videoBox { margin-top:14px; max-width:100%; border-radius:10px; border:1px solid #1f2937; }
    .videoBox { display:none; overflow:hidden; }
    video { width:100%; height:auto; display:block; background:#0b1220; }
    canvas { display:none; }
    code { background:#0b1220; padding:2px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <div class="card">
    <h2>Upload image to S3</h2>
    <p class="muted">Images only, max 10 MB. Target: <code>uploaded/</code></p>

    <div class="row">
      <!-- file input also hints mobile to open camera via capture attr -->
      <input id="file" type="file" accept="image/*" capture="environment" />
      <button id="go" class="btn">Upload</button>
      <button id="openCam" class="btn">Use Camera</button>
      <button id="snap" class="btn ghost" style="display:none">Snap</button>
      <button id="retake" class="btn gray" style="display:none">Retake</button>
      <button id="closeCam" class="btn gray" style="display:none">Close</button>
    </div>

    <progress id="bar" value="0" max="100"></progress>
    <div class="muted" id="status">Idle</div>

    <div class="videoBox" id="videoBox">
      <video id="video" playsinline></video>
    </div>

    <img id="preview" class="thumb" alt="Preview" />
    <canvas id="canvas"></canvas>

    <p class="muted">Object key: <code id="key">—</code></p>
  </div>

<script>
const API = "https://2upze5woa9.execute-api.ap-southeast-1.amazonaws.com/presign";
const MAX_BYTES = 10 * 1024 * 1024;

const fileEl  = document.getElementById('file');
const goBtn   = document.getElementById('go');
const openCam = document.getElementById('openCam');
const snapBtn = document.getElementById('snap');
const retake  = document.getElementById('retake');
const closeCam= document.getElementById('closeCam');

const bar     = document.getElementById('bar');
const status  = document.getElementById('status');
const keyLbl  = document.getElementById('key');
const preview = document.getElementById('preview');
const video   = document.getElementById('video');
const videoBox= document.getElementById('videoBox');
const canvas  = document.getElementById('canvas');

let stream = null;

// ========== Existing “choose file” upload ==========
goBtn.onclick = async () => {
  const f = fileEl.files[0];
  if (!f) return alert('Choose a file first');
  if (!f.type.startsWith('image/')) return alert('Images only');
  if (f.size > MAX_BYTES) return alert('Max 10 MB');

  // preview
  const reader = new FileReader();
  reader.onload = () => { preview.src = reader.result; preview.style.display = 'block'; };
  reader.readAsDataURL(f);

  try {
    await uploadFile(f.name, f.type, f);
  } catch (e) { console.error(e); alert(e.message || e); }
};

// ========== New: Camera flow ==========
openCam.onclick = async () => {
  try {
    // HTTPS is required on the web; localhost is allowed by most browsers
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } },
      audio: false
    });
    video.srcObject = stream;
    await video.play();
    videoBox.style.display = 'block';
    snapBtn.style.display = 'inline-block';
    retake.style.display = 'none';
    closeCam.style.display = 'inline-block';
    status.textContent = 'Camera ready — frame your shot';
  } catch (err) {
    console.error(err);
    alert('Could not access camera. Try HTTPS/localhost or check permissions.');
  }
};

snapBtn.onclick = async () => {
  if (!stream) return;
  const w = video.videoWidth || 1280;
  const h = video.videoHeight || 720;
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(video, 0, 0, w, h);

  // Convert to JPEG (quality ~92%). Re-compress if needed to keep under 10MB.
  const blob = await canvasToJpeg(canvas, 0.92);
  if (blob.size > MAX_BYTES) {
    const q = Math.max(0.6, 0.92 * (MAX_BYTES / blob.size)); // naive scale-down
    const blob2 = await canvasToJpeg(canvas, q);
    if (blob2.size > MAX_BYTES) return alert('Captured image exceeds 10MB even after compression.');
    await uploadCaptured(blob2);
  } else {
    await uploadCaptured(blob);
  }
};

retake.onclick = () => {
  if (!stream) return;
  status.textContent = 'Camera ready — retake';
  preview.style.display = 'none';
  snapBtn.style.display = 'inline-block';
  retake.style.display = 'none';
};

closeCam.onclick = () => stopStream();

async function uploadCaptured(blob) {
  try {
    stopStream(); // freeze frame after capture
    const urlObj = URL.createObjectURL(blob);
    preview.src = urlObj; preview.style.display = 'block';

    // give it a filename
    const ts = new Date().toISOString().replace(/[:.]/g,'');
    const name = `camera_${ts}.jpg`;
    await uploadFile(name, 'image/jpeg', blob);
    retake.style.display = 'inline-block';
  } catch (e) {
    console.error(e);
    alert(e.message || e);
  }
}

function stopStream() {
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
  video.srcObject = null;
  videoBox.style.display = 'none';
  snapBtn.style.display = 'none';
  closeCam.style.display = 'none';
}

// helpers
function canvasToJpeg(c, quality=0.92) {
  return new Promise((resolve, reject) => {
    c.toBlob(b => b ? resolve(b) : reject(new Error('Failed to create image')), 'image/jpeg', quality);
  });
}

// shared upload logic
async function uploadFile(filename, contentType, dataBlob) {
  status.textContent = 'Requesting URL…';
  const r = await fetch(API, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ filename, contentType })
  });
  if (!r.ok) throw new Error('Presign failed');
  const { url, key } = await r.json();
  keyLbl.textContent = key;

  status.textContent = 'Uploading…'; bar.value = 0;
  await putWithProgress(url, dataBlob, contentType);
  status.textContent = 'Done ✅'; bar.value = 100;
}

function putWithProgress(url, fileOrBlob, contentType) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('PUT', url, true);
    xhr.setRequestHeader('Content-Type', contentType || 'application/octet-stream');
    xhr.upload.onprogress = (e) => { if (e.lengthComputable) bar.value = Math.round((e.loaded / e.total) * 100); };
    xhr.onload  = () => (xhr.status >= 200 && xhr.status < 300) ? resolve() : reject(new Error('S3 responded ' + xhr.status));
    xhr.onerror = () => reject(new Error('Network error'));
    xhr.send(fileOrBlob);
  });
}
</script>
</body>
</html>
