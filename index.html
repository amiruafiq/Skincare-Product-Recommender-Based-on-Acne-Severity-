<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Afiq — S3 Image Uploader</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 0; background:#0f172a; color:#e2e8f0; display:grid; place-items:center; min-height:100vh; }
    .card { width:min(820px,94vw); background:#111827; border:1px solid #1f2937; border-radius:16px; padding:24px; box-shadow:0 10px 30px rgba(0,0,0,.35); }
    h2 { margin:0 0 8px; }
    .muted { color:#9ca3af; font-size:13px; }
    .btn { padding:10px 16px; border-radius:10px; background:#2563eb; color:#fff; border:0; cursor:pointer; font-weight:600; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .btn.ghost { background:#334155; }
    .btn.gray { background:#6b7280; }
    .row { display:flex; gap:10px; flex-wrap:wrap; margin:10px 0; }
    progress { width:100%; height:12px; margin-top:10px; }
    .thumb, .videoBox { margin-top:14px; max-width:100%; border-radius:10px; border:1px solid #1f2937; }
    .videoBox { display:none; overflow:hidden; }
    video { width:100%; height:auto; display:block; background:#0b1220; }
    canvas { display:none; }
    code { background:#0b1220; padding:2px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <div class="card">
    <h2>Upload image to S3</h2>
    <p class="muted">Images only, max 10 MB. Target: <code>uploaded/</code></p>

    <div class="row">
      <!-- Hint mobile browsers to use the FRONT camera -->
      <input id="file" type="file" accept="image/*" capture="user" />
      <button id="go" class="btn">Upload</button>
      <button id="openCam" class="btn">Use Camera</button>
      <button id="flip" class="btn ghost" style="display:none">Flip</button>
      <button id="snap" class="btn ghost" style="display:none">Snap</button>
      <button id="retake" class="btn gray" style="display:none">Retake</button>
      <button id="closeCam" class="btn gray" style="display:none">Close</button>
    </div>

    <progress id="bar" value="0" max="100"></progress>
    <div class="muted" id="status">Idle</div>

    <div class="videoBox" id="videoBox">
      <video id="video" playsinline></video>
    </div>

    <img id="preview" class="thumb" alt="Preview" />
    <canvas id="canvas"></canvas>

    <p class="muted">Object key: <code id="key">—</code></p>
  </div>

<script>
const API = "https://2upze5woa9.execute-api.ap-southeast-1.amazonaws.com/presign";
const MAX_BYTES = 10 * 1024 * 1024;

const fileEl  = document.getElementById('file');
const goBtn   = document.getElementById('go');
const openCam = document.getElementById('openCam');
const flipBtn = document.getElementById('flip');
const snapBtn = document.getElementById('snap');
const retake  = document.getElementById('retake');
const closeCam= document.getElementById('closeCam');

const bar     = document.getElementById('bar');
const status  = document.getElementById('status');
const keyLbl  = document.getElementById('key');
const preview = document.getElementById('preview');
const video   = document.getElementById('video');
const videoBox= document.getElementById('videoBox');
const canvas  = document.getElementById('canvas');

let stream = null;
let facing = 'environment'; // default for desktop
if (/Mobi|Android|iPhone/i.test(navigator.userAgent)) facing = 'user'; // phone = front cam by default

// ===== File picker upload =====
goBtn.onclick = async () => {
  const f = fileEl.files[0];
  if (!f) return alert('Choose a file first');
  if (!f.type.startsWith('image/')) return alert('Images only');
  if (f.size > MAX_BYTES) return alert('Max 10 MB');

  const reader = new FileReader();
  reader.onload = () => { preview.src = reader.result; preview.style.display = 'block'; };
  reader.readAsDataURL(f);

  try { await uploadFile(f.name, f.type, f); }
  catch (e) { console.error(e); alert(e.message || e); }
};

// ===== Camera flow =====
openCam.onclick = async () => { await startCamera(facing); };

flipBtn.onclick = async () => {
  facing = (facing === 'user') ? 'environment' : 'user';
  await startCamera(facing, /*restart*/true);
};

snapBtn.onclick = async () => {
  if (!stream) return;
  const w = video.videoWidth || 1280, h = video.videoHeight || 720;
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(video, 0, 0, w, h);

  const blob = await canvasToJpeg(canvas, 0.92);
  const finalBlob = (blob.size > MAX_BYTES) ? await canvasToJpeg(canvas, Math.max(0.6, 0.92 * (MAX_BYTES / blob.size))) : blob;
  if (finalBlob.size > MAX_BYTES) return alert('Captured image exceeds 10MB even after compression.');

  stopStream();
  const urlObj = URL.createObjectURL(finalBlob);
  preview.src = urlObj; preview.style.display = 'block';

  const ts = new Date().toISOString().replace(/[:.]/g,'');
  const name = `camera_${ts}.jpg`;
  try { await uploadFile(name, 'image/jpeg', finalBlob); retake.style.display = 'inline-block'; }
  catch (e) { console.error(e); alert(e.message || e); }
};

retake.onclick = () => { if (!stream) startCamera(facing); };

closeCam.onclick = () => stopStream();

async function startCamera(desiredFacing, restart=false) {
  try {
    if (restart) stopStream();
    const constraintsList = [
      { video: { facingMode: { exact: desiredFacing } }, audio: false },
      { video: { facingMode: desiredFacing }, audio: false },
      { video: true, audio: false } // final fallback
    ];
    let lastErr = null;
    for (const c of constraintsList) {
      try {
        stream = await navigator.mediaDevices.getUserMedia(c);
        break;
      } catch (e) { lastErr = e; }
    }
    if (!stream) throw lastErr || new Error('No camera available');

    video.srcObject = stream;
    await video.play();
    videoBox.style.display = 'block';
    snapBtn.style.display = 'inline-block';
    flipBtn.style.display = 'inline-block';
    retake.style.display = 'none';
    closeCam.style.display = 'inline-block';
    status.textContent = `Camera ready — ${desiredFacing === 'user' ? 'front' : 'rear'}`;
  } catch (err) {
    console.error(err);
    alert('Could not access camera. Use HTTPS/localhost and allow permissions.');
  }
}

function stopStream() {
  if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
  video.srcObject = null;
  videoBox.style.display = 'none';
  snapBtn.style.display = 'none';
  flipBtn.style.display = 'none';
  closeCam.style.display = 'none';
}

function canvasToJpeg(c, quality=0.92) {
  return new Promise((resolve, reject) => {
    c.toBlob(b => b ? resolve(b) : reject(new Error('Failed to create image')), 'image/jpeg', quality);
  });
}

// ===== Shared upload logic =====
async function uploadFile(filename, contentType, dataBlob) {
  status.textContent = 'Requesting URL…';
  const r = await fetch(API, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ filename, contentType })
  });
  if (!r.ok) throw new Error('Presign failed');
  const { url, key } = await r.json();
  keyLbl.textContent = key;

  status.textContent = 'Uploading…'; bar.value = 0;
  await putWithProgress(url, dataBlob, contentType);
  status.textContent = 'Done ✅'; bar.value = 100;
}

function putWithProgress(url, fileOrBlob, contentType) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('PUT', url, true);
    xhr.setRequestHeader('Content-Type', contentType || 'application/octet-stream');
    xhr.upload.onprogress = (e) => { if (e.lengthComputable) bar.value = Math.round((e.loaded / e.total) * 100); };
    xhr.onload  = () => (xhr.status >= 200 && xhr.status < 300) ? resolve() : reject(new Error('S3 responded ' + xhr.status));
    xhr.onerror = () => reject(new Error('Network error'));
    xhr.send(fileOrBlob);
  });
}
</script>
</body>
</html>
